{% extends 'base.html' %}
{% block title %}Take Exam{% endblock %}
{% block content %}
  <style>
    /* Disable text selection and copying */
    body {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    /* Allow selection in agent section */
    .agent-section {
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
    }
    /* Screenshot prevention overlay */
    .screenshot-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: white;
      z-index: 9999;
      display: none;
      opacity: 0;
      transition: none;
    }
    .screenshot-overlay.active {
      opacity: 1;
    }
  </style>
  <!-- Screenshot prevention overlay -->
  <div id="screenshotOverlay" class="screenshot-overlay"></div>
  <h2>{{ exam.title }}</h2>
  <p>{{ exam.description }}</p>
  <div id="timer" class="mb-3 alert alert-info"></div>
  <div id="enter-fullscreen" class="mb-3 p-4 bg-warning rounded">
    <h4>Enter Fullscreen to Begin</h4>
    <p>For exam integrity, please enter fullscreen. The exam will start once you enter fullscreen. Exiting fullscreen will finalize and submit your attempt.</p>
    <button id="begin-btn" class="btn btn-lg btn-primary">Enter Fullscreen &amp; Begin Exam</button>
  </div>

  <div class="mb-3 p-3 bg-light border rounded agent-section">
    <h5>Optional: Native Monitoring Agent</h5>
    <p>If you install the provided native monitoring agent on your Windows machine, it can report which application/window is active when you switch away from the exam. This requires you to run the agent locally and paste the token below into the agent so it can send reports for this attempt.</p>
    <p><strong>Attempt ID:</strong> <code>{{ attempt.id }}</code></p>
    <p><strong>Agent Token:</strong> <code id="agent-token">{{ attempt.agent_token or 'not-available' }}</code></p>
    <p><a href="{{ url_for('static', filename='exam_proctor_extension.zip') }}" download>Download Browser Extension</a> (Recommended for enhanced security)</p>
    <p class="small text-muted">Instructions: Download the extension, unzip, go to Chrome Extensions (chrome://extensions/), enable Developer Mode, load unpacked, and select the folder. The extension will automatically close other tabs and provide token copying.</p>
  </div>

  <form method="post" id="exam-form" style="display:none">
    {% for q in questions %}
      <div class="mb-3">
        <p><strong>Q{{ loop.index }}.</strong> {{ q.text }}</p>
        {% for choice in q.choices %}
          <div class="form-check">
            <input class="form-check-input" type="radio" name="question_{{ q.id }}" id="q{{ q.id }}_{{ loop.index0 }}" value="{{ loop.index0 }}"
              {% if saved_answers and (q.id|string) in saved_answers and saved_answers[q.id|string] is not none and saved_answers[q.id|string] == loop.index0 %}checked{% endif %}>
            <label class="form-check-label" for="q{{ q.id }}_{{ loop.index0 }}">{{ choice }}</label>
          </div>
        {% endfor %}
      </div>
    {% endfor %}
    <button class="btn btn-primary" type="submit">Submit Exam</button>
  </form>

  <script>
    // show elapsed and remaining time; autosave and auto-submit
    const deadlineMs = {{ deadline_ts if deadline_ts is not none else 'null' }};
    const startedAtMs = {{ started_at_ms if started_at_ms is not none else 'null' }};
    const lecturerStartedMs = {{ lecturer_started_ms if lecturer_started_ms is not none else 'null' }};

    function formatTime(ms){
      const total = Math.max(0, Math.floor(ms/1000));
      const hrs = Math.floor(total/3600);
      let rem = total % 3600;
      const mins = Math.floor(rem/60);
      const secs = rem % 60;
      return `${hrs}h ${mins}m ${secs}s`;
    }

    function updateTimer(){
      const now = Date.now();
      let text = '';
      if(lecturerStartedMs){
        text += `Lecturer started: ${new Date(lecturerStartedMs).toLocaleString()}. `;
      }
      if(startedAtMs){
        const elapsed = now - startedAtMs;
        text += `You started: ${new Date(startedAtMs).toLocaleString()} (Elapsed: ${formatTime(elapsed)}). `;
      }
      if(deadlineMs){
        const remaining = deadlineMs - now;
        if(remaining <= 0){
          text += 'Time left: 0s';
          document.getElementById('timer').innerText = text;
          // auto-submit form
          const f = document.querySelector('form');
          if(f){ f.submit(); }
          return;
        } else {
          text += `Time left: ${formatTime(remaining)}`;
        }
      }
      document.getElementById('timer').innerText = text;
    }

    // autosave answers every 30 seconds
    async function autosave(){
      const data = {};
      {% for q in questions %}
        {
          const el = document.querySelector('input[name="question_{{ q.id }}"]:checked');
          data['{{ q.id }}'] = el ? parseInt(el.value) : null;
        }
      {% endfor %}
      try{
        await fetch('{{ url_for('save_attempt', attempt_id=attempt.id) }}', {
          method: 'POST', headers: {'Content-Type':'application/json'},
          body: JSON.stringify({answers: data})
        });
      }catch(e){
        console.warn('Autosave failed', e);
      }
    }

    // anti-cheat reporting
    async function reportEvent(name, data){
      try{
        await fetch('{{ url_for('report_event', attempt_id=attempt.id) }}', {
          method: 'POST', headers: {'Content-Type':'application/json'},
          body: JSON.stringify({event: name, data: data || {}})
        });
      }catch(e){ console.warn('report failed', e); }
    }

    // Fullscreen helper and enforcement: require user gesture to enter fullscreen
    function tryEnterFullscreen(){
      try{
        if(document.documentElement.requestFullscreen){
          return document.documentElement.requestFullscreen();
        }
      }catch(e){ return Promise.reject(e); }
      return Promise.reject(new Error('Fullscreen not supported'));
    }

    let hadFullscreen = false;
    document.addEventListener('fullscreenchange', function(){
      const isFs = !!document.fullscreenElement;
      if(hadFullscreen && !isFs){
        // user exited fullscreen after starting -> immediate finish
        reportEvent('fullscreen_exit', {});
        fetch('{{ url_for('force_finish', attempt_id=attempt.id) }}', {method: 'POST'}).catch(()=>{});
        setTimeout(()=>{ window.location.href = '{{ url_for('student_exams') }}'; }, 1000);
      }
      hadFullscreen = isFs;
    });

    // Detect visibility changes and window blur/focus
    document.addEventListener('visibilitychange', function(){
      if(document.hidden){ reportEvent('exam_portal_hidden', {}); }
      else { reportEvent('exam_portal_visible', {}); }
    });
    window.addEventListener('blur', function(){ reportEvent('exam_portal_blur', {}); });
    window.addEventListener('focus', function(){ reportEvent('exam_portal_focus', {}); });

    // Prevent paste and record copy/paste events
    document.addEventListener('copy', function(e){
      // Allow copying in agent section
      if(!e.target.closest('.agent-section')){
        try{ const sel = window.getSelection().toString(); reportEvent('copy', {text: sel}); }catch(e){}
        e.preventDefault(); // Prevent copying outside agent section
      }
    });
    document.addEventListener('paste', function(e){
      try{
        const clip = (e.clipboardData && e.clipboardData.getData) ? e.clipboardData.getData('text') : '';
        reportEvent('paste', {text: clip});
        // optionally prevent paste to block answers
        e.preventDefault();
      }catch(e){ }
    });

    // Prevent right-click context menu
    document.addEventListener('contextmenu', function(e){
      e.preventDefault();
      reportEvent('right_click', {});
    });

    // Prevent cut
    document.addEventListener('cut', function(e){
      e.preventDefault();
      reportEvent('cut', {});
    });

    // Comprehensive keyboard blocking
    function blockRestrictedKeys(e){
      const key = (e.key || '').toLowerCase();
      const code = e.keyCode;
      const combo = {ctrl:e.ctrlKey, shift:e.shiftKey, alt:e.altKey, meta:e.metaKey};
      const shouldBlock =
        (combo.alt && code === 115) ||          // Alt+F4
        (combo.alt && code === 9)  ||           // Alt+Tab
        (code === 91 || code === 92 || key === 'meta') || // Win key
        (combo.ctrl && combo.alt && code === 46) ||       // Ctrl+Alt+Del
        (combo.ctrl && combo.shift && code === 27) ||     // Ctrl+Shift+Esc
        (code === 123) ||                                 // F12
        (combo.ctrl && combo.shift && code === 73) ||     // Ctrl+Shift+I
        (combo.ctrl && combo.shift && code === 67) ||     // Ctrl+Shift+C
        (key === 'printscreen' || code === 44) ||         // PrintScreen
        (combo.ctrl && key === 's') ||                    // Ctrl+S
        (combo.ctrl && key === 'p');                      // Ctrl+P
      if(shouldBlock){
        e.preventDefault();
        e.stopPropagation();
        if(e.stopImmediatePropagation){ e.stopImmediatePropagation(); }
        reportEvent('exam_portal_shortcut_blocked', {key, code, combo});
        if(key === 'printscreen' || code === 44){ showScreenshotOverlay(); }
        return false;
      }
    }

    window.addEventListener('keydown', blockRestrictedKeys, true);
    document.addEventListener('keydown', blockRestrictedKeys, true);

    // Function to show screenshot overlay
    function showScreenshotOverlay(){
      const overlay = document.getElementById('screenshotOverlay');
      overlay.classList.add('active');
      overlay.style.display = 'block';
      setTimeout(() => {
        overlay.classList.remove('active');
        setTimeout(() => {
          overlay.style.display = 'none';
        }, 200);
      }, 800);
    }

    // Enhanced screenshot detection with multiple methods
    (function detectScreenCapture(){
      let checkInterval = setInterval(() => {
        if(document.hidden) return;
        
        try{
          // Method 1: Canvas fingerprinting
          const canvas = document.createElement('canvas');
          canvas.width = canvas.height = 100;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#FF0000';
          ctx.fillRect(0, 0, 100, 100);
          
          const imageData = ctx.getImageData(0, 0, 100, 100);
          const data = imageData.data;
          
          // Check if canvas was rendered
          let colored = false;
          for(let i = 0; i < data.length; i += 4){
            if(data[i] > 200){ colored = true; break; }
          }
          
          if(!colored){
            reportEvent('exam_portal_screenshot_possible', {});
            showScreenshotOverlay();
          }
        }catch(e){ }
      }, 1000);
    })();

    // Prevent window from being minimized or closed
    window.addEventListener('beforeunload', function(e){
      reportEvent('window_unload_attempt', {});
      e.preventDefault();
      e.returnValue = '';
      return false;
    });

    // Block fullscreen exit by preventing Escape key
    document.addEventListener('keydown', function(e){
      if(e.keyCode === 27 && document.fullscreenElement){
        e.preventDefault();
        reportEvent('fullscreen_escape_attempt', {});
        return false;
      }
    }, true);

    // Begin button: require user gesture to enter fullscreen then show exam
    const beginBtn = document.getElementById('begin-btn');
    const enterOverlay = document.getElementById('enter-fullscreen');
    const examForm = document.getElementById('exam-form');
    let timersStarted = false;

    async function beginExam(){
      // try fullscreen first
      try{
        await tryEnterFullscreen();
        // mark that fullscreen was active at some point
        hadFullscreen = !!document.fullscreenElement;
      }catch(e){
        // fullscreen unavailable or blocked; record and continue
        reportEvent('fullscreen_unavailable', {error: (e && e.message) ? e.message : String(e)});
      }

      // reveal the exam form and hide overlay
      if(enterOverlay) enterOverlay.style.display = 'none';
      if(examForm) examForm.style.display = 'block';

      // start timers and autosave once
      if(!timersStarted){
        updateTimer();
        setInterval(updateTimer, 1000);
        setInterval(autosave, 30000);
        timersStarted = true;
      }
    }

    if(beginBtn){
      beginBtn.addEventListener('click', function(e){
        e.preventDefault();
        beginExam();
      });
    } else {
      // no begin button - auto-begin (fallback)
      beginExam();
    }

    // Removed auto-begin in popup to ensure user gesture for fullscreen
  </script>
{% endblock %}
