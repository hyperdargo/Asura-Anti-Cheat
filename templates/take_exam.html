{% extends 'base.html' %}
{% block title %}Take Exam{% endblock %}
{% block content %}
  <style>
    /* Disable text selection and copying */
    body {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    /* Allow selection in agent section */
    .agent-section {
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
    }
    /* Screenshot prevention overlay */
    .screenshot-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: white;
      z-index: 9999;
      display: none;
      opacity: 0;
      transition: none;
    }
    .screenshot-overlay.active {
      opacity: 1;
    }
    .fullscreen-exit-overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.92);
      color: #fff;
      z-index: 10000;
      text-align: center;
      padding: 2rem;
    }
  </style>
  <!-- Screenshot prevention overlay -->
  <div id="screenshotOverlay" class="screenshot-overlay"></div>
  <div id="fullscreenExitOverlay" class="fullscreen-exit-overlay">
    <div>
      <h3>Fullscreen Ended</h3>
      <p>Your attempt has been finalized because fullscreen was interrupted.</p>
    </div>
  </div>
  <h2>{{ exam.title }}</h2>
  <p>{{ exam.description }}</p>
  <div id="timer" class="mb-3 alert alert-info"></div>
  <div id="enter-fullscreen" class="mb-3 p-4 bg-warning rounded">
    <h4>Enter Fullscreen to Begin</h4>
    <p>For exam integrity, please enter fullscreen. The exam will start once you enter fullscreen. Exiting fullscreen will finalize and submit your attempt.</p>
    <button id="begin-btn" class="btn btn-lg btn-primary">Enter Fullscreen &amp; Begin Exam</button>
  </div>

  <div class="mb-3 p-3 bg-light border rounded agent-section">
    <h5>Optional: Native Monitoring Agent</h5>
    <p>If you install the provided native monitoring agent on your Windows machine, it can report which application/window is active when you switch away from the exam. This requires you to run the agent locally and paste the token below into the agent so it can send reports for this attempt.</p>
    <p><strong>Attempt ID:</strong> <code>{{ attempt.id }}</code></p>
    <p><strong>Agent Token:</strong> <code id="agent-token">{{ attempt.agent_token or 'not-available' }}</code></p>
    <p><a href="{{ url_for('static', filename='exam_proctor_extension.zip') }}" download>Download Browser Extension</a> (Recommended for enhanced security)</p>
    <p class="small text-muted">Instructions: Download the extension, unzip, go to Chrome Extensions (chrome://extensions/), enable Developer Mode, load unpacked, and select the folder. The extension will automatically close other tabs and provide token copying.</p>
  </div>

  <form method="post" id="exam-form" style="display:none">
    {% for q in questions %}
      <div class="mb-3">
        <p><strong>Q{{ loop.index }}.</strong> {{ q.text }}</p>
        {% for choice in q.choices %}
          <div class="form-check">
            <input class="form-check-input" type="radio" name="question_{{ q.id }}" id="q{{ q.id }}_{{ loop.index0 }}" value="{{ loop.index0 }}"
              {% if saved_answers and (q.id|string) in saved_answers and saved_answers[q.id|string] is not none and saved_answers[q.id|string] == loop.index0 %}checked{% endif %}>
            <label class="form-check-label" for="q{{ q.id }}_{{ loop.index0 }}">{{ choice }}</label>
          </div>
        {% endfor %}
      </div>
    {% endfor %}
    <button class="btn btn-primary" type="submit">Submit Exam</button>
  </form>

  <script>
    // show elapsed and remaining time; autosave and auto-submit
    const deadlineMs = {{ deadline_ts if deadline_ts is not none else 'null' }};
    const startedAtMs = {{ started_at_ms if started_at_ms is not none else 'null' }};
    const lecturerStartedMs = {{ lecturer_started_ms if lecturer_started_ms is not none else 'null' }};
    const forceFinishUrl = '{{ url_for('force_finish', attempt_id=attempt.id) }}';
    const redirectUrl = '{{ url_for('student_exams') }}';
    const attemptFinishedKey = 'attempt_{{ attempt.id }}_fullscreen_finished';
    if(localStorage.getItem(attemptFinishedKey) === '1'){
      window.location.replace(redirectUrl);
    }
    let hadFullscreen = false;
    let fullscreenExitHandled = false;
    let suppressBeforeUnload = false;

    function formatTime(ms){
      const total = Math.max(0, Math.floor(ms/1000));
      const hrs = Math.floor(total/3600);
      let rem = total % 3600;
      const mins = Math.floor(rem/60);
      const secs = rem % 60;
      return `${hrs}h ${mins}m ${secs}s`;
    }

    function updateTimer(){
      const now = Date.now();
      let text = '';
      if(lecturerStartedMs){
        text += `Lecturer started: ${new Date(lecturerStartedMs).toLocaleString()}. `;
      }
      if(startedAtMs){
        const elapsed = now - startedAtMs;
        text += `You started: ${new Date(startedAtMs).toLocaleString()} (Elapsed: ${formatTime(elapsed)}). `;
      }
      if(deadlineMs){
        const remaining = deadlineMs - now;
        if(remaining <= 0){
          text += 'Time left: 0s';
          document.getElementById('timer').innerText = text;
          // auto-submit form
          const f = document.querySelector('form');
          if(f){ f.submit(); }
          return;
        } else {
          text += `Time left: ${formatTime(remaining)}`;
        }
      }
      document.getElementById('timer').innerText = text;
    }

    // autosave answers every 30 seconds
    async function autosave(){
      const data = {};
      {% for q in questions %}
        {
          const el = document.querySelector('input[name="question_{{ q.id }}"]:checked');
          data['{{ q.id }}'] = el ? parseInt(el.value) : null;
        }
      {% endfor %}
      try{
        await fetch('{{ url_for('save_attempt', attempt_id=attempt.id) }}', {
          method: 'POST', headers: {'Content-Type':'application/json'},
          body: JSON.stringify({answers: data})
        });
      }catch(e){
        console.warn('Autosave failed', e);
      }
    }

    // anti-cheat reporting
    async function reportEvent(name, data){
      try{
        await fetch('{{ url_for('report_event', attempt_id=attempt.id) }}', {
          method: 'POST', headers: {'Content-Type':'application/json'},
          body: JSON.stringify({event: name, data: data || {}})
        });
      }catch(e){ console.warn('report failed', e); }
    }

    // Fullscreen helper and enforcement: require user gesture to enter fullscreen
    function tryEnterFullscreen(){
      try{
        if(document.documentElement.requestFullscreen){
          return document.documentElement.requestFullscreen();
        }
      }catch(e){ return Promise.reject(e); }
      return Promise.reject(new Error('Fullscreen not supported'));
    }

    function showScreenshotOverlay(){
      const overlay = document.getElementById('screenshotOverlay');
      overlay.classList.add('active');
      overlay.style.display = 'block';
      setTimeout(() => {
        overlay.classList.remove('active');
        setTimeout(() => {
          overlay.style.display = 'none';
        }, 200);
      }, 800);
    }

    async function handleFullscreenExit(reason){
      if(fullscreenExitHandled){ return; }
      fullscreenExitHandled = true;
      suppressBeforeUnload = true;
      window.removeEventListener('beforeunload', beforeUnloadHandler);
      localStorage.setItem(attemptFinishedKey, '1');
      reportEvent('exam_portal_fullscreen_exit', {reason});
      const blocker = document.getElementById('fullscreenExitOverlay');
      if(blocker){ blocker.style.display = 'flex'; }
      const form = document.getElementById('exam-form');
      if(form){
        form.querySelectorAll('input, button, textarea, select').forEach(el => { el.disabled = true; });
      }
      try{
        await sendForceFinish();
      }catch(err){
        console.warn('force finish failed', err);
      }
      setTimeout(() => { window.location.replace(redirectUrl); }, 800);
    }
    function sendForceFinish(){
      if(navigator.sendBeacon){
        const ok = navigator.sendBeacon(forceFinishUrl, new Blob([], {type:'text/plain'}));
        if(ok){ return Promise.resolve(); }
      }
      return fetch(forceFinishUrl, {
        method: 'POST',
        credentials: 'include',
        keepalive: true
      }).catch(() => {});
    }
    function beforeUnloadHandler(e){
      if(suppressBeforeUnload){ return; }
      reportEvent('window_unload_attempt', {});
      e.preventDefault();
      e.returnValue = '';
      return '';
    }

    // document.addEventListener('fullscreenchange', ...) uses the original hadFullscreen variable
    document.addEventListener('fullscreenchange', function(){
      const isFs = !!document.fullscreenElement;
      if(isFs){
        hadFullscreen = true;
      }else if(hadFullscreen){
        handleFullscreenExit('fullscreenchange');
      }
    });
    document.addEventListener('fullscreenerror', function(){
      handleFullscreenExit('fullscreenerror');
    });

    // Detect visibility changes and window blur/focus
    document.addEventListener('visibilitychange', function(){
      if(document.hidden){ reportEvent('exam_portal_hidden', {}); }
      else { reportEvent('exam_portal_visible', {}); }
    });
    window.addEventListener('blur', function(){ reportEvent('exam_portal_blur', {}); });
    window.addEventListener('focus', function(){ reportEvent('exam_portal_focus', {}); });

    // Prevent paste and record copy/paste events
    document.addEventListener('copy', function(e){
      // Allow copying in agent section
      if(!e.target.closest('.agent-section')){
        try{ const sel = window.getSelection().toString(); reportEvent('copy', {text: sel}); }catch(e){}
        e.preventDefault(); // Prevent copying outside agent section
      }
    });
    document.addEventListener('paste', function(e){
      try{
        const clip = (e.clipboardData && e.clipboardData.getData) ? e.clipboardData.getData('text') : '';
        reportEvent('paste', {text: clip});
        // optionally prevent paste to block answers
        e.preventDefault();
      }catch(e){ }
    });

    // Prevent right-click context menu
    document.addEventListener('contextmenu', function(e){
      e.preventDefault();
      reportEvent('right_click', {});
    });

    // Prevent cut
    document.addEventListener('cut', function(e){
      e.preventDefault();
      reportEvent('cut', {});
    });

    // Comprehensive keyboard blocking
    function blockRestrictedKeys(e){
      const key = (e.key || '').toLowerCase();
      const code = e.keyCode;
      const combo = {ctrl:e.ctrlKey, shift:e.shiftKey, alt:e.altKey, meta:e.metaKey};
      const shouldBlock =
        (combo.alt && code === 115) ||          // Alt+F4
        (combo.alt && code === 9)  ||           // Alt+Tab
        (code === 91 || code === 92 || key === 'meta') || // Win key
        (combo.ctrl && combo.alt && code === 46) ||       // Ctrl+Alt+Del
        (combo.ctrl && combo.shift && code === 27) ||     // Ctrl+Shift+Esc
        (code === 123) ||                                 // F12
        (combo.ctrl && combo.shift && code === 73) ||     // Ctrl+Shift+I
        (combo.ctrl && combo.shift && code === 67) ||     // Ctrl+Shift+C
        (code === 122) ||                                 // F11
        (key === 'printscreen' || code === 44) ||         // PrintScreen
        (combo.ctrl && key === 's') ||                    // Ctrl+S
        (combo.ctrl && key === 'p');                      // Ctrl+P
      if(shouldBlock){
        e.preventDefault();
        e.stopPropagation();
        if(e.stopImmediatePropagation){ e.stopImmediatePropagation(); }
        reportEvent('exam_portal_shortcut_blocked', {key, code, combo});
        if(key === 'printscreen' || code === 44){ showScreenshotOverlay(); }
        return false;
      }
    }

    window.addEventListener('keydown', blockRestrictedKeys, true);
    document.addEventListener('keydown', blockRestrictedKeys, true);

    // Enhanced screenshot detection with multiple methods
    (function detectScreenCapture(){
      let checkInterval = setInterval(() => {
        if(document.hidden) return;
        
        try{
          // Method 1: Canvas fingerprinting
          const canvas = document.createElement('canvas');
          canvas.width = canvas.height = 100;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#FF0000';
          ctx.fillRect(0, 0, 100, 100);
          
          const imageData = ctx.getImageData(0, 0, 100, 100);
          const data = imageData.data;
          
          // Check if canvas was rendered
          let colored = false;
          for(let i = 0; i < data.length; i += 4){
            if(data[i] > 200){ colored = true; break; }
          }
          
          if(!colored){
            reportEvent('exam_portal_screenshot_possible', {});
            showScreenshotOverlay();
          }
        }catch(e){ }
      }, 1000);
    })();

    // Prevent window from being minimized or closed
    window.addEventListener('beforeunload', beforeUnloadHandler);
    // Block fullscreen exit by preventing Escape key
    document.addEventListener('keydown', function(e){
      if(e.keyCode === 27 && document.fullscreenElement){
        e.preventDefault();
        reportEvent('fullscreen_escape_attempt', {});
        return false;
      }
      if(e.keyCode === 27 && !document.fullscreenElement && hadFullscreen){
        handleFullscreenExit('escape_key');
      }
    }, true);

    // Begin button: require user gesture to enter fullscreen then show exam
    const beginBtn = document.getElementById('begin-btn');
    const enterOverlay = document.getElementById('enter-fullscreen');
    const examForm = document.getElementById('exam-form');
    let timersStarted = false;

    async function beginExam(){
      // try fullscreen first
      try{
        await tryEnterFullscreen();
        // mark that fullscreen was active at some point
        hadFullscreen = !!document.fullscreenElement;
      }catch(e){
        // fullscreen unavailable or blocked; record and continue
        reportEvent('fullscreen_unavailable', {error: (e && e.message) ? e.message : String(e)});
      }

      // reveal the exam form and hide overlay
      if(enterOverlay) enterOverlay.style.display = 'none';
      if(examForm) examForm.style.display = 'block';

      // start timers and autosave once
      if(!timersStarted){
        updateTimer();
        setInterval(updateTimer, 1000);
        setInterval(autosave, 30000);
        timersStarted = true;
      }
    }

    if(beginBtn){
      beginBtn.addEventListener('click', function(e){
        e.preventDefault();
        beginExam();
      });
    } else {
      // no begin button - auto-begin (fallback)
      beginExam();
    }

    // Removed auto-begin in popup to ensure user gesture for fullscreen

    // ===== REAL-TIME EXAM TERMINATION LISTENER =====
    // Connect to Socket.IO for real-time termination detection
    const socket = io();
    const attemptId = {{ attempt.id }};
    
    // Join the attempt room to receive termination events
    socket.on('connect', function() {
      console.log('Connected to exam monitoring');
      socket.emit('join_attempt', { attempt_id: attemptId });
    });

    // Listen for exam termination event from staff/teacher
    socket.on('exam_terminated', function(data) {
      if (data.attempt_id === attemptId) {
        // Exam has been terminated by staff/teacher
        alert('⚠️ YOUR EXAM HAS BEEN TERMINATED\n\n' + data.message + '\n\nYour current answers have been saved and the exam will now close.');
        
        // Try to submit current state before closing
        fetch('{{ url_for("save_attempt", attempt_id=attempt.id) }}', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ answers: getCurrentAnswers() })
        }).finally(function() {
          // Force finish the exam
          fetch('{{ url_for("force_finish", attempt_id=attempt.id) }}', {
            method: 'POST'
          }).finally(function() {
            // Redirect to student exams page
            window.location.href = '{{ url_for("student_exams") }}';
          });
        });
      }
    });

    // Helper function to get current answers
    function getCurrentAnswers() {
      const answers = {};
      document.querySelectorAll('input[type="radio"]:checked').forEach(function(input) {
        const qId = input.name.replace('question_', '');
        answers[qId] = parseInt(input.value);
      });
      return answers;
    }

    // Handle disconnection
    socket.on('disconnect', function() {
      console.log('Disconnected from exam monitoring');
    });
  </script>
{% endblock %}
